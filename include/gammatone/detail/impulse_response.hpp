/*
  Copyright (C) 2015 Mathieu Bernard <mathieu_bernard@laposte.net>

  This file is part of libgammatone

  libgammatone is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with libgammatone. If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef GAMMATONE_DETAIL_IMPULSE_RESPONSE_H
#define GAMMATONE_DETAIL_IMPULSE_RESPONSE_H

#include <gammatone/detail/utils.hpp>
#include <gammatone/detail/decibel.hpp>
#include <boost/math/constants/constants.hpp>
#include <algorithm>
#include <vector>

namespace gammatone
{
  namespace detail
  {
    //! Impulse response generation
    /*!
      \class impulse_response

      This class provide static methods for impulse response
      generation. Both theoretical and obtained impulse responses are
      provided.
    */
    class impulse_response
    {
    public:

      //! Compute the theoretical impulse response for given filter and
      //! duration
      /*!
        \tparam Filter     Type of the gammatone filter
        \tparam Container  Type of the output container

        \param filter   The gammatone filter to be processed
        \param duration The duration for computing timestamps (in s)

        \return The computed impulse response
      */
      template
      <
      class Filter,
      template<class...> class Container = std::vector
      >
      static Container<typename Filter::scalar_type> theorical(
        const Filter& filter,
        const typename Filter::scalar_type& duration);


      //! Compute the theoretical impulse response for given filter and
      //! timestamps
      /*!
        The timestamps range in [first,last) is expressed in seconds)
        and should be generated by time().

        \tparam Filter     Type of the gammatone filter
        \tparam Container  Type of the output container

        \param filter The gammatone filter to be processed
        \param first  First iterator on the timestamps container
        \param last    Last iterator on the timestamps container

        \return The computed impulse response
      */
      template
      <
        class Filter,
        class Iterator,
        template<class...> class Container = std::vector
        >
      static Container<typename Filter::scalar_type> theorical(
        const Filter& filter,
        const Iterator& first,
        const Iterator& last);

      //! Compute the theoretical impulse response for given explicit
      //! parameters and timestamps
      /*!
        The timestamps range in [first,last) is expressed in seconds)
        and should be generated by time().

        \tparam Scalar    Type of scalar values
        \tparam Iterator   Type of iterator on timestamps
        \tparam Container  Type of the output container

        \param center_frequency  The filter center frequency (Hz)
        \param bandwidth         The filter bandwidth (Hz)
        \param first             First iterator on the timestamps container
        \param last              Last iterator on the timestamps container

        \return The computed impulse response
      */
      template
      <
        class Scalar,
        class Iterator,
        template<class...> class Container = std::vector
        >
      static Container<Scalar> theorical(
        const Scalar& center_frequency,
        const Scalar& bandwidth,
        const Iterator& first,
        const Iterator& last);


      //! Compute the theoretical impulse response for given explicit
      //! parameters and duration
      /*!
        \tparam Scalar    Type of scalar values
        \tparam Container  Type of the output container

        \param center_frequency  The filter center frequency (Hz)
        \param bandwidth         The filter bandwidth (Hz)
        \param sample_frequency  The sample frequency (Hz)
        \param duration          The duration for computing timestamps (in s)

        \return The computed impulse response
      */
      template
      <
        class Scalar,
        template<class...> class Container = std::vector
        >
      static Container<Scalar> theorical(
        const Scalar& center_frequency,
        const Scalar& bandwidth,
        const Scalar& sample_frequency,
        const Scalar& duration);



      //! Compute the theoretical impulse response for given filter and
      //! attenuation
      /*!
        The generated impulse response length is given as an attenuation
        level (in dB). To avoid too long (or infinite for positive
        attenuation) impulse responses, the maximum length is bounded by
        a maximum duration (in s). Default maximum length is 1 s.

        \tparam Filter     Type of the gammatone filter
        \tparam Container  Type of the output container

        \param filter         The filter for which to compute the impulse response
        \param attenuation    The desired maximum attenuation (dB).
        \param max_duration   Maximum duration of the impuse response (s).

        \return The computed impulse response
      */
      template
      <
        class Filter,
        template<class...> class Container = std::vector
        >
      static Container<typename Filter::scalar_type> theorical_attenuate(
        const Filter& filter,
        const typename Filter::scalar_type& attenuation,
        const typename Filter::scalar_type max_duration = 1.0);


      //! Compute the theoretical impulse response for given filter
      //! parameters and attenuation
      /*!
        The generated impulse response length is given as an attenuation
        level (in dB). To avoid too long (or infinite) impulse
        responses, the maximum length is bounded by a maximum duration
        (in s). Default maximum length is 1 s.

        \tparam Scalar     Type of scalar values
        \tparam dB         Type of attenuation parameter
        \tparam Container  Type of the output container

        \param center_frequency  The filter center frequency (Hz)
        \param bandwidth         The filter bandwidth (Hz)
        \param sample_frequency  The sample frequency (Hz)
        \param attenuation       The desired maximum attenuation (in dB). Must be negative.
        \param max_duration      Maximum duration of the impuse response.

        \return The computed impulse response
      */
      template
      <
        class Scalar,
        class dB = Scalar,
        template<class...> class Container = std::vector
        >
      static Container<Scalar> theorical_attenuate(
        const Scalar& center_frequency,
        const Scalar& bandwidth,
        const Scalar& sample_frequency,
        const dB& attenuation,
        const Scalar max_duration = 1.0);



      //! Compute the implemented impulse response for given filter and timestamps
      /*!
        \tparam Filter     Type of the input gammatone filter
        \tparam Iterator   Type of the timestamps iterator
        \tparam Container  Type of the output container

        \param filter The gammatone filter to be processed
        \param first             First iterator on the timestamps container
        \param last              Last iterator on the timestamps container

        \return The computed impulse response
      */
      template
      <
        class Filter,
        class Iterator,
        template<class...> class Container = std::vector
        >
      static Container<typename Filter::scalar_type> implemented(
        const Filter& filter,
        const Iterator& first,
        const Iterator& last);

      template
      <
        class Filter,
        class Iterator,
        template<class...> class Container = std::vector
        >
      static Container<typename Filter::scalar_type> implemented(
        Filter& filter,
        const Iterator& first,
        const Iterator& last);


      //! Compute the implemented impulse response for given filter and duration
      /*!
        \tparam F Type of the input gammatone filter
        \tparam U Type of the output paired containers

        \param filter   The gammatone filter to be processed
        \param duration The duration for computing timestamps (in s)

        \return The computed impulse response
      */
      template
      <
        class Filter,
        template<class...> class Container = std::vector
	>
      static Container<typename Filter::scalar_type> implemented(
        const Filter& filter,
        const typename Filter::scalar_type& duration);


      //! Returns a container of timestamps for given sample frequency and duration
      /*!
        \tparam Scalar    Type of scalar values
        \tparam Container Type of the output container

        \param sample_frequency  The sample frequency (Hz)
        \param duration          The duration for computing the timestamps (s)

        \return A container of timestamps (in s) of size duration*sample_frequency+1
      */
      template<class Scalar,
               template<class...> class Container = std::vector >
      static Container<Scalar> time(const Scalar& sample_frequency,
                                    const Scalar& duration);

    private:
      //! Compute the theorical impulse response of a single value
      /*!
        \tparam Scalar    Type of the scalar values

        \param center_frequency  The filter center frequency (Hz)
        \param bandwidth         The filter bandwidth (Hz)
        \param timestamp         The timestamp for which to compute the result (s)
        \param phase             The phase for which to compute the result (rad)

        \return The computed impulse response value
      */
      template<class Scalar>
      static Scalar formula_ir(const Scalar& center_frequency,
                               const Scalar& bandwidth,
                               const Scalar& timestamp,
                               const Scalar& phase = 0.0);
    };
  }
}


template<class Scalar, class dB, template<class...> class Container>
Container<Scalar> gammatone::detail::impulse_response::
theorical_attenuate(const Scalar& center_frequency,
                    const Scalar& bandwidth,
                    const Scalar& sample_frequency,
                    const dB& attenuation,
                    const Scalar max_duration)
{
  Container<Scalar> t = time(sample_frequency, max_duration);

  auto ir = theorical(center_frequency,bandwidth,t.cbegin(),t.cend());
  gammatone::detail::shrink_to_attenuation(ir, static_cast<Scalar>(attenuation));

  return ir;
}

template<class Filter, template<class...> class Container>
Container<typename Filter::scalar_type> gammatone::detail::impulse_response::
theorical_attenuate(const Filter& filter,
                    const typename Filter::scalar_type& attenuation,
                    const typename Filter::scalar_type max_duration)
{
  return theorical_attenuate(filter.center_frequency(),
                             filter.bandwidth(),
                             filter.sample_frequency(),
                             attenuation, max_duration);
}

template<class Filter, class Iterator, template<class...> class Container>
Container<typename Filter::scalar_type> gammatone::detail::impulse_response::
theorical(const Filter& filter,
          const Iterator& first,
          const Iterator& last)
{
  return theorical(filter.center_frequency(), filter.bandwidth(), first, last);
}

template<class Filter, template<class...> class Container>
Container<typename Filter::scalar_type> gammatone::detail::impulse_response::
theorical(const Filter& filter,
          const typename Filter::scalar_type& duration)
{
  Container<typename Filter::scalar_type> t = time(filter.sample_frequency(), duration);
  return theorical(filter.center_frequency(),filter.bandwidth(),t.cbegin(),t.cend());
}


template<class Scalar, class Iterator, template<class...> class Container>
Container<Scalar> gammatone::detail::impulse_response::
theorical(const Scalar& center_frequency,
          const Scalar& bandwidth,
          const Iterator& first,
          const Iterator& last)
{

  Container<Scalar> ir(std::distance(first,last));
  std::transform(first,last,ir.begin(),
                 [&](const auto& t){return formula_ir(center_frequency,bandwidth,t);});
  return ir;
}


template<class Scalar, template<class...> class Container>
Container<Scalar> gammatone::detail::impulse_response::
theorical(const Scalar& center_frequency,
          const Scalar& bandwidth,
          const Scalar& sample_frequency,
          const Scalar& duration)
{
  const auto t = time(sample_frequency, duration);
  return theorical(center_frequency,bandwidth,t.cbegin(),t.cend());
}


template<class Filter, class Iterator, template<class...> class Container>
Container<typename Filter::scalar_type> gammatone::detail::impulse_response::
implemented(const Filter& filter,
            const Iterator& first,
            const Iterator& last)
{
  Filter f(filter);
  return implemented(f,first,last);
}


template<class Filter, class Iterator, template<class...> class Container>
Container<typename Filter::scalar_type> gammatone::detail::impulse_response::
implemented(Filter& filter,
            const Iterator& first,
            const Iterator& last)
{
  filter.reset();

  // allocation for output
  Container<typename Filter::scalar_type> ir(std::distance(first,last));

  // compute the first sample (= 1)
  auto it = ir.begin();
  *it++ = filter.compute(1.0);

  // compute other samples (= 0)
  std::for_each(it,ir.end(),[&](auto& x){x = filter.compute(0.0);});

  return ir;
}


template<class Filter, template<class...> class Container>
Container<typename Filter::scalar_type> gammatone::detail::impulse_response::
implemented(const Filter& filter,
            const typename Filter::scalar_type& duration)
{
  Container<typename Filter::scalar_type> t = time(filter.sample_frequency(), duration);
  return implemented(filter,t.begin(), t.end());
}


template<class Scalar, template<class...> class Container>
Container<Scalar> gammatone::detail::impulse_response::
time(const Scalar& sample_frequency,
     const Scalar& duration)
{
  const std::size_t size = sample_frequency*duration + 1;
  return gammatone::detail::linspace(0.0,duration,size);
}


template<class Scalar>
Scalar gammatone::detail::impulse_response::
formula_ir(const Scalar& center_frequency,
           const Scalar& bandwidth,
           const Scalar& time,
           const Scalar& phase)
{
  const Scalar tt = 2 * boost::math::constants::pi<Scalar>() * time;
  return std::pow(time, 3) * std::exp(-tt*bandwidth) * std::cos(tt*center_frequency+phase);
}

#endif // GAMMATONE_DETAIL_IMPULSE_RESPONSE_H
