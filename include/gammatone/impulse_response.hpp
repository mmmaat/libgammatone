/*
  Copyright (C) 2015 Mathieu Bernard <mathieu_bernard@laposte.net>

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef GAMMATONE_IMPULSE_RESPONSE_H
#define GAMMATONE_IMPULSE_RESPONSE_H

#include <utils/range.hpp>
#include <boost/math/constants/constants.hpp> // for pi
#include <algorithm>
#include <vector>

namespace gammatone
{
  //! Impulse response generation
  /*!
    \class impulse_response

    This class provide static methods for impulse response
    generation. Both theorical and obtained impulse responses are
    provided.
  */
  class impulse_response
  {
  public:

    //! Compute the theorical impulse response for given filter and
    //! duration
    /*!
      \tparam Filter     Type of the gamamtone filter
      \tparam Container  Type of the output container

      \param filter   The gammatone filter to be processed
      \param duration The duration for computing timestamps (in s)

      \return The computed impulse response
    */
    template<class Filter,
             class Container = std::vector<typename Filter::scalar_type> >
    static Container theorical(const Filter& filter,
                               const typename Filter::scalar_type& duration);


    //! Compute the theorical impulse response for given filter and
    //! timestamps
    /*!
      The timestamps range in [first,last) is expressed in seconds)
      and should be generated by time().

      \tparam Filter     Type of the gammatone filter
      \tparam Container  Type of the output container

      \param filter The gammatone filter to be processed
      \param first  First iterator on the timestamps container
      \param last    Last iterator on the timestamps container

      \return The computed impulse response
    */
    template<class Filter,
             class Iterator,
             class Container = std::vector<typename Filter::scalar_type> >
    static Container theorical(const Filter& filter,
                               const Iterator& first,
                               const Iterator& last);


    //! Compute the theorical impulse response for given explicit
    //! parameters and timestamps
    /*!
      The timestamps range in [first,last) is expressed in seconds)
      and should be generated by time().

      \tparam Filter     Type of the gammatone filter
      \tparam Iterator   Type of iterator on timestamps
      \tparam Container  Type of the output container

      \param center_frequency  The filter center frequency (Hz)
      \param bandwidth         The filter bandwidth (Hz)
      \param first             First iterator on the timestamps container
      \param last              Last iterator on the timestamps container

      \return The computed impulse response
    */
    template<class Scalar,
             class Iterator,
             class Container = std::vector<Scalar> >
    static Container theorical(const Scalar& center_frequency,
                               const Scalar& bandwidth,
                               const Iterator& first,
                               const Iterator& last);


    //! Compute the theorical impulse response for given explicit
    //! parameters and duration
    /*!
      \tparam Filter     Type of the gamamtone filter
      \tparam Container  Type of the output container

      \param center_frequency  The filter center frequency (Hz)
      \param bandwidth         The filter bandwidth (Hz)
      \param sample_frequency  The sample frequency (Hz)
      \param duration          The duration for computing timestamps (in s)

      \return The computed impulse response
    */
    template<class Scalar,
             class Container = std::vector<Scalar> >
    static Container theorical(const Scalar& center_frequency,
                               const Scalar& bandwidth,
                               const Scalar& sample_frequency,
                               const Scalar& duration);

    //! Compute the implemented impulse response for given filter and timestamps
    /*!
      \tparam Filter     Type of the input gammatone filter
      \tparam Iterator   Type of the timestamps iterator
      \tparam Container  Type of the output container

      \param filter The gammatone filter to be processed
      \param first             First iterator on the timestamps container
      \param last              Last iterator on the timestamps container

      \return The computed impulse response
    */
    template<class Filter,
             class Iterator,
             class Container = std::vector<typename Filter::scalar_type> >
    static Container implemented(const Filter& filter,
                                 const Iterator& first,
                                 const Iterator& last);


    //! Compute the implemented impulse response for given filter and duration
    /*!
      \tparam F Type of the input gammatone filter
      \tparam U Type of the output paired containers

      \param filter   The gammatone filter to be processed
      \param duration The duration for computing timestamps (in s)

      \return The computed impulse response
    */
    template<class Filter,
             class Container = std::vector<typename Filter::scalar_type> >
    static Container implemented(const Filter& filter,
                                 const typename Filter::scalar_type& duration);


    //! Returns a container of timestamps for given sample frequency and duration
    /*!
      \tparam Scalar    Type of the scalar values
      \tparam Container Type of the output container

      \param sample_frequency  The sample frequency (Hz)
      \param duration          The duration for computing the timestamps (s)

      \return A container of timestamps (in s) of size duration*sample_frequency+1
    */
    template<class Scalar,
             class Container = std::vector<Scalar> >
    static Container time(const Scalar& sample_frequency,
                          const Scalar& duration);

  private:
    //! Compute the theorical impulse response of a single value
    /*!
      \tparam Scalar    Type of the scalar values

      \param center_frequency  The filter center frequency (Hz)
      \param bandwidth         The filter bandwidth (Hz)
      \param timestamp         The timestamp for which to compute the result (s)
      \param phase             The phase for which to compute the result (rad)

      \return The computed impulse response value
    */
    template<class Scalar>
    static Scalar formula_ir(const Scalar& center_frequency,
                             const Scalar& bandwidth,
                             const Scalar& timestamp,
                             const Scalar& phase = 0.0);

  };
}


template<class Filter, class Container>
Container gammatone::impulse_response::theorical(const Filter& filter,
                                                 const typename Filter::scalar_type& duration)
{
  Container t = time(filter.sample_frequency(), duration);
  return std::move(theorical(filter.center_frequency(),filter.bandwidth(),t.cbegin(),t.cend()));
}

template<class Filter, class Iterator, class Container>
Container gammatone::impulse_response::theorical(const Filter& filter,
                                                 const Iterator& first,
                                                 const Iterator& last)
{
  return std::move(theorical(filter.center_frequency(), filter.bandwidth(), first, last));
}

template<class Scalar, class Iterator, class Container>
Container gammatone::impulse_response::theorical(const Scalar& center_frequency,
                                                 const Scalar& bandwidth,
                                                 const Iterator& first,
                                                 const Iterator& last)
{

  Container ir(std::distance(first,last));
  std::transform(first,last,ir.begin(),
                 [&](const auto& t){return formula_ir(center_frequency,bandwidth,t);});
  return std::move(ir);
}


template<class Scalar, class Container>
Container gammatone::impulse_response::theorical(const Scalar& center_frequency,
                                                 const Scalar& bandwidth,
                                                 const Scalar& sample_frequency,
                                                 const Scalar& duration)
{
  const auto t = time(sample_frequency, duration);
  return std::move(theorical(center_frequency,bandwidth,t.cbegin(),t.cend()));
}


template<class Filter, class Iterator, class Container>
Container gammatone::impulse_response::implemented(const Filter& filter,
                                                   const Iterator& first,
                                                   const Iterator& last)
{
  // copy the filter and reset before computation
  Filter f(filter);
  f.reset();

  // allocation for output
  Container ir(std::distance(first,last));

  // compute the first sample (= 1)
  auto it = ir.begin();
  *it++ = f.compute(1.0);

  // compute other samples (= 0)
  std::for_each(it,ir.end(),[&](auto& x){x = f.compute(0.0);});

  return std::move(ir);
}


template<class Filter, class Container>
Container gammatone::impulse_response::implemented(const Filter& filter,
						   const typename Filter::scalar_type& duration)
{
  Container t = time(filter.sample_frequency(), duration);
  return std::move(implemented(filter,t.begin(), t.end()));
}


template<class Scalar, class Container>
Container gammatone::impulse_response::time(const Scalar& sample_frequency,
					    const Scalar& duration)
{
  return std::move(utils::linspace(0.0,duration, sample_frequency*duration+1));
}


template<class Scalar>
Scalar gammatone::impulse_response::formula_ir(const Scalar& center_frequency,
					       const Scalar& bandwidth,
					       const Scalar& time,
					       const Scalar& phase)
{
  const Scalar tt = 2 * boost::math::constants::pi<Scalar>() * time;
  return std::pow(time, 3) * std::exp(-tt*bandwidth) * std::cos(tt*center_frequency+phase);
}

#endif // GAMMATONE_IMPULSE_RESPONSE_H
